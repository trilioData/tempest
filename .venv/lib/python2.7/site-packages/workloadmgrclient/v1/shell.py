# Copyright (c) 2014 TrilioData, Inc.
# All Rights Reserved.

from __future__ import print_function

import argparse
import os
import sys
import time
import ast
import json

from workloadmgrclient import exceptions
from workloadmgrclient import utils
from workloadmgrclient.openstack.common import strutils

def _poll_for_status(poll_fn, obj_id, action, final_ok_states,
                     poll_period=5, show_progress=True):
    """Block while an action is being performed, periodically printing
    progress.
    """
    def print_progress(progress):
        if show_progress:
            msg = ('\rInstance %(action)s... %(progress)s%% complete'
                   % dict(action=action, progress=progress))
        else:
            msg = '\rInstance %(action)s...' % dict(action=action)

        sys.stdout.write(msg)
        sys.stdout.flush()

    print()
    while True:
        obj = poll_fn(obj_id)
        status = obj.status.lower()
        progress = getattr(obj, 'progress', None) or 0
        if status in final_ok_states:
            print_progress(100)
            print("\nFinished")
            break
        elif status == "error":
            print("\nError %(action)s instance" % locals())
            break
        else:
            print_progress(progress)
            time.sleep(poll_period)

def _find_setting(cs, setting_name):
    """Get a setting by name."""
    return utils.find_resource(cs.settings, setting_name)     
            
def _find_workload_type(cs, workload_type_id):
    """Get a workload_type by ID."""
    return utils.find_resource(cs.workload_types, workload_type_id)            

def _find_workload(cs, workload_id):
    """Get a workload by ID."""
    return utils.find_resource(cs.workloads, workload_id)

def _find_snapshot(cs, snapshot_id):
    """Get a workload snapshot by ID."""
    return utils.find_resource(cs.snapshots, snapshot_id)

def _find_restore(cs, restore_id):
    """Get a workload snapshot restore by ID."""
    return utils.find_resource(cs.restores, restore_id)

def _find_testbubble(cs, testbubble_id):
    """Get a workload snapshot testbubble by ID."""
    return utils.find_resource(cs.testbubbles, testbubble_id)

def _find_transfer(cs, transfer):
    """Gets a transfer by name or ID."""
    return utils.find_resource(cs.transfers, transfer)

def _translate_keys(collection, convert):
    for item in collection:
        keys = item.__dict__.keys()
        for from_key, to_key in convert:
            if from_key in keys and to_key not in keys:
                setattr(item, to_key, item._info[from_key])

def _translate_workload_snapshot_keys(collection):
    convert = [('workloadId', 'workload_Id')]
    _translate_keys(collection, convert)


def _extract_metadata(args):
    metadata = {}
    for metadatum in args.metadata:
        # unset doesn't require a val, so we have the if/else
        if '=' in metadatum:
            (key, value) = metadatum.split('=', 1)
        else:
            key = metadatum
            value = None

        metadata[key] = value
    return metadata


def _print_type_and_extra_specs_list(vtypes):
    formatters = {'extra_specs': _print_type_extra_specs}
    utils.print_list(vtypes, ['ID', 'Name', 'extra_specs'], formatters)


def do_endpoints(cs, args):
    """Discover endpoints that get returned from the authenticate services."""
    catalog = cs.client.service_catalog.catalog
    if cs.client.auth_version == 3:
       for e in catalog['token']['catalog']:
           e_dict = {}
           for end in e['endpoints']:
               if end['interface'] == 'public':
                   e_dict['publicUrl'] = end['url']
               elif end['interface'] == 'internal':
                   e_dict['internalUrl'] = end['url']
               elif end['interface'] == 'admin':
                   e_dict['adminUrl'] = end['url']
               e_dict['region'] = end['region']
               e_dict['id'] = end['id']
           e_dict['id'] = e['id']
           utils.print_dict(e_dict, e['name'])
    else:
         for e in catalog['access']['serviceCatalog']:
             utils.print_dict(e['endpoints'][0], e['name'])


def do_credentials(cs, args):
    """Show user credentials returned from auth."""
    catalog = cs.client.service_catalog.catalog
    if cs.client.auth_version == 3:
       utils.print_dict(catalog['token']['user'], "User Credentials")
       del catalog['token']['user']
       del catalog['token']['catalog']
       utils.print_dict(catalog['token'], "Token")
    else:
         utils.print_dict(catalog['access']['user'], "User Credentials")
         utils.print_dict(catalog['access']['token'], "Token")

_quota_resources = ['volumes', 'snapshots', 'gigabytes']


def _print_type_extra_specs(vol_type):
    try:
        return vol_type.get_keys()
    except exceptions.NotFound:
        return "N/A"

'''@utils.arg('--metadata',
     metavar="<key=value>",
     action='append',
     dest='metadata',
     default=[],
     help=  "Specify a key value pairs to include in the workload_type metadata "
            "Specify option multiple times to include multiple keys. "
            "key=value")
@utils.arg('--id', metavar='<id>',
           help='Optional workload_type uuid. (Default=None)',
           default=None)
@utils.arg('--display-name', metavar='<display-name>',
           help='Optional workload_type name. (Default=None)',
           default=None)
@utils.arg('--display-description', metavar='<display-description>',
           help='Optional workload_type description. (Default=None)',
           default=None)
@utils.arg('--is-public',
           type=strutils.bool_from_string, metavar='{True,False}',
           help='Make workload_type accessible to the public.',
           default=False)
@utils.service_type('workloads')
def do_workload_type_create(cs, args):
    """Creates a workload_type."""
    metadata = {}
    for metadata_str in args.metadata:
        err_msg = ("Invalid metadata argument '%s'. metadata arguments must be of the "
                   "form --metadata <key=value>" % metadata_str)

        try:
            k, v = metadata_str.split("=", 1)
        except ValueError as e:
            raise exceptions.CommandError(err_msg)

        if k in metadata:
            metadata[k] = v
        else:
            metadata.setdefault(k, v)

   
    cs.workload_types.create(metadata,
                             args.id,
                             args.display_name,
                             args.display_description,
                             args.is_public)'''

'''@utils.arg('workload_type_id', metavar='<workload_type_id>', help='ID of the workload_type.')
@utils.arg('--metadata',
     metavar="<key=value>",
     action='append',
     dest='metadata',
     default=[],
     help=  "Specify a key value pairs to include in the workload_type metadata "
            "Specify option multiple times to include multiple keys. "
            "key=value")
@utils.service_type('workloads')
def do_workload_type_discover_instances(cs, args):
    """Discover instances of a workload_type."""
    metadata = {}
    for metadata_str in args.metadata:
        err_msg = ("Invalid metadata argument '%s'. metadata arguments must be of the "
                   "form --metadata <key=value>" % metadata_str)
        for kv_str in metadata_str.split(","):
            try:
                k, v = kv_str.split("=", 1)
            except ValueError as e:
                raise exceptions.CommandError(err_msg)

            if k in metadata:
                metadata[k] = v
            else:
                metadata.setdefault(k, v)
    instances = cs.workload_types.discover_instances(args.workload_type_id, metadata)
    utils.print_dict(instances,wrap=100)'''
 
@utils.arg('workload_type_id', metavar='<workload_type_id>', help='ID of the workload_type.')
@utils.service_type('workloads')
def do_workload_type_show(cs, args):
    """Show details about a workload_type."""
    workload_type = _find_workload_type(cs, args.workload_type_id)
    info = dict()
    info.update(workload_type._info)

    if 'links' in info:
        info.pop('links')

    utils.print_dict(info, wrap=100)


@utils.service_type('workloads')
def do_workload_type_list(cs, args):
    """List all the workload_type."""
    workload_types = cs.workload_types.list()
    columns = ['ID', 'Name']
    utils.print_list(workload_types, columns)


'''@utils.arg('workload_type_id', metavar='<workload_type_id>',
           help='ID of the workload_type to delete.')
@utils.service_type('workloads')
def do_workload_type_delete(cs, args):
    """Remove a workload."""
    workload_type = _find_workload_type(cs, args.workload_type_id)
    workload_type.delete()'''

@utils.arg('--instance',
     metavar="<instance-id=instance-uuid>",
     action='append',
     dest='instances',
     required=True,
     help="Required to set atleast one instance, Specify an instance to include in the workload. "
           "Specify option multiple times to include multiple instances. "
           "instance-id: include the instance with this UUID ")
@utils.arg('--display-name', metavar='<display-name>',
           help='Optional workload name. (Default=None)',
           default=None)
@utils.arg('--display-description', metavar='<display-description>',
           help='Optional workload description. (Default=None)',
           default=None)
@utils.arg('--workload-type-id', metavar='<workload-type-id>',
           help='Optional Workload Type ID, (Default=Serial)',
           default=None)
@utils.arg('--source-platform', metavar='<source-platform>',
           help='Optional workload source platform (Default=None)',
           default=None)
@utils.arg('--jobschedule',
     metavar="<key=key-name>",
     action='append',
     dest='jobschedule',
     default=[],
     help=  "Specify following key value pairs for jobschedule "
            "Specify option multiple times to include multiple keys. "
            " 'start_date' : '06/05/2014' "
            " 'end_date' : '07/15/2014' "
            " 'start_time' : '2:30 PM' "
            " 'interval' : '1 hr' "
            " 'retention_policy_type' : 'Number of Snapshots to Keep' or 'Number of days to retain Snapshots' "
            " 'retention_policy_value' : '30' "
            "  ,                              "
            "For example --jobschedule start_date='mm/dd/yy' --jobschedule enabled=True"
            "In order to enable/disable scheduler pass enabled True / enabled False")
@utils.arg('--metadata',
     metavar="<key=key-name>",
     action='append',
     dest='metadata',
     default=[],
     help=  "Specify a key value pairs to include in the workload_type metadata "
            "Specify option multiple times to include multiple keys. "
            "key=value")


#@utils.arg("--workloadids",
#     metavar="<workloadid>",
#     action="append",
#     dest="workloadids",
#     default=[],
#     help=  "Specify workload ids  "
#            " for creating composite workload "
#            "--workloadids <workloadid> --workloadids <workloadid>")

@utils.service_type('workloads')
def do_workload_create(cs, args):
    """Creates a workload."""
    instances = []
    for instance_str in args.instances:
        err_msg = ("Invalid instance argument '%s'. Instance arguments must be of the "
                   "form --instance <instance-id=instance-uuid>" % instance_str)
        instance_info = {"instance-id": ""}

        for kv_str in instance_str.split(","):
            try:
                k, v = kv_str.split("=", 1)
            except ValueError as e:
                raise exceptions.CommandError(err_msg)

            if k in instance_info:
                instance_info[k] = v
            else:
                raise exceptions.CommandError(err_msg)

        if not instance_info['instance-id']:
            raise exceptions.CommandError(err_msg)

        instances.append(instance_info)
        
    jobschedule = {}
    for jobschedule_str in args.jobschedule:
        err_msg = ("Invalid jobschedule argument '%s'. jobschedule arguments must be of the "
                   "form --jobschedule <key=value>" % jobschedule_str)

        for kv_str in jobschedule_str.split(","):
            try:
                k, v = kv_str.split("=", 1)
            except ValueError as e:
                raise exceptions.CommandError(err_msg)

            if k in jobschedule:
                jobschedule[k] = v
            else:
                jobschedule.setdefault(k, v)     

    if len(jobschedule) >= 1 and 'enabled' not in jobschedule:
       raise exceptions.CommandError("Please specify --jobschedule enabled option in order to set scheduler for this workload")
    metadata = {}
    for metadata_str in args.metadata:
        err_msg = ("Invalid metadata argument '%s'. metadata arguments must be of the "
                   "form --metadata <key=value>" % metadata_str)

        for kv_str in metadata_str.split(","):
            try:
                k, v = kv_str.split("=", 1)
            except ValueError as e:
                raise exceptions.CommandError(err_msg)

            if k in metadata:
                metadata[k] = v
            else:
                metadata.setdefault(k, v)  

    '''
    workloadids = []
    err_msg = ("Composite workload type must specify workload-ids ")
    workload_type = _find_workload_type(cs, args.workload_type_id)
    if workload_type.name == 'Composite':
       if len(args.workloadids) == 0:
          raise exceptions.CommandError(err_msg)

    workload_info = []
    composite = {}
    workload_data = []

    for ids in args.workloadids:
        workload = _find_workload(cs, ids)
        d = {}
        d["text"] = str(workload.name)
        d["value"] = str(workload.id)
        workload_info.append(d)
        inner_list = []
        d = {}
        d["type"] = "workload"
        info = dict()
        info.update(workload._info)

        info['jobschedule']['enabled'] = str(info['jobschedule']['enabled'])
        info['interval'] = str(info['interval'])
        d['data'] = ast.literal_eval(json.dumps(info))
        inner_list.append(d)
        dt = {}
        dt["flow"] = "serial"
        dt['children'] = inner_list
        workload_data.append(dt)

    d = {}
    d["flow"] = "serial"
    d["children"] = workload_data
    composite['compworkloads'] = json.dumps(workload_info)
    composite['workloadgraph'] = json.dumps(d)
    if workload_type.name == 'Composite':
       metadata = composite   
    '''
    workload = cs.workloads.create(args.display_name,
                        args.display_description,
                        args.workload_type_id,
                        args.source_platform,
                        instances,
                        jobschedule,
                        metadata)
    
    columns = ['ID', 'Name', 'Status']
    utils.print_object(workload, columns)

@utils.arg('workload_id', metavar='<workload_id>', help='ID of the workload.')
@utils.arg('--display-name', metavar='<display-name>',
           help='Optional workload name. (Default=None)',
           default=None)
@utils.arg('--display-description', metavar='<display-description>',
           help='Optional workload description. (Default=None)',
           default=None)
@utils.arg('--instance',
     metavar="<instance-id=instance-uuid>",
     action='append',
     dest='instances',
     default=[],
     help="Specify an instance to include in the workload. "
           "Specify option multiple times to include multiple instances. "
           "instance-id: include the instance with this UUID ")
@utils.arg('--jobschedule',
     metavar="<key=key-name>",
     action='append',
     dest='jobschedule',
     default=[],
     help=  "Specify following key value pairs for jobschedule "
            "Specify option multiple times to include multiple keys. "
            " 'start_date' : '06/05/2014' "
            " 'end_date' : '07/15/2014' "
            " 'start_time' : '2:30 PM' "
            " 'interval' : '1 hr' "
            " 'retention_policy_type' : 'Number of Snapshots to Keep' or 'Number of days to retain Snapshots' "
            " 'retention_policy_value' : '30' ")            

@utils.arg('--metadata',
     metavar="<key=key-name>",
     action='append',
     dest='metadata',
     default=[],
     help=  "Specify a key value pairs to include in the workload_type metadata "
            "Specify option multiple times to include multiple keys. "
            "key=value")
@utils.service_type('workloads')
def do_workload_modify(cs, args):
    """Modify a workload."""
    workload = _find_workload(cs, args.workload_id)
    instances = []
    for instance_str in args.instances:
        err_msg = ("Invalid instance argument '%s'. Instance arguments must be of the "
                   "form --instance <instance-id=instance-uuid>" % instance_str)
        instance_info = {"instance-id": ""}

        for kv_str in instance_str.split(","):
            try:
                k, v = kv_str.split("=", 1)
            except ValueError as e:
                raise exceptions.CommandError(err_msg)

            if k in instance_info:
                instance_info[k] = v
            else:
                raise exceptions.CommandError(err_msg)

        if not instance_info['instance-id']:
            raise exceptions.CommandError(err_msg)

        instances.append(instance_info)
        
    jobschedule = {}
    for jobschedule_str in args.jobschedule:
        err_msg = ("Invalid jobschedule argument '%s'. jobschedule arguments must be of the "
                   "form --jobschedule <key=value>" % jobschedule_str)

        for kv_str in jobschedule_str.split(","):
            try:
                k, v = kv_str.split("=", 1)
            except ValueError as e:
                raise exceptions.CommandError(err_msg)

            if k in jobschedule:
                jobschedule[k] = v
            else:
                jobschedule.setdefault(k, v)     
                
    metadata = {}
    for metadata_str in args.metadata:
        err_msg = ("Invalid metadata argument '%s'. metadata arguments must be of the "
                   "form --metadata <key=value>" % metadata_str)

        for kv_str in metadata_str.split(","):
            try:
                k, v = kv_str.split("=", 1)
            except ValueError as e:
                raise exceptions.CommandError(err_msg)

            if k in metadata:
                metadata[k] = v
            else:
                metadata.setdefault(k, v)  
                
                
    workload.update(workload.id,
                    args.display_name,
                    args.display_description,
                    instances,
                    jobschedule,
                    metadata)


@utils.arg('workload_id', metavar='<workload_id>', help='ID of the workload.')
@utils.arg('--verbose', metavar='<verbose>',
           help="Get detailed information of workload with specifying --verbose,  "
                "Example command - workloadmgr --verbose workload-show <workload-id>",
           default=False)
@utils.service_type('workloads')
def do_workload_show(cs, args):
    """Show details about a workload."""
    workload = _find_workload(cs, args.workload_id)
    info = dict()
    info.update(workload._info)
    if 'links' in info:
        info.pop('links')

    if 'metadata' in info:
       metadata = info.pop('metadata')

    if 'jobschedule' in info:
       jobschedule = info.pop('jobschedule')

    info['jobschedule'] = jobschedule['enabled']
    for i,val in enumerate(info['instances']):
        removed_metadata = info['instances'][i].pop('metadata')
    utils.print_dict(info, wrap=100)
    if args.verbose == True:
       if 'topology' in metadata:
          metadata.pop('topology')

       if 'workloadgraph' in metadata:
          metadata.pop('workloadgraph')

       utils.print_dict(metadata,'Metadata')
       utils.print_dict(jobschedule,'Jobschedule')

"""@utils.arg('workload_id', metavar='<workload_id>', help='ID of the workload.')
@utils.service_type('workloads')
def do_workload_get_workflow(cs, args):
    workflow = cs.workloads.get_workflow(args.workload_id)
    utils.print_dict(workflow, wrap=100) """

'''@utils.arg('workload_id', metavar='<workload_id>', help='ID of the workload.')
@utils.service_type('workloads')
def do_workload_get_topology(cs, args):
    """Show topology of a workload."""
    topology = cs.workloads.get_topology(args.workload_id)
    utils.print_dict(topology, wrap=100)
   
#Disabling discover_instance from CLI
#@utils.arg('workload_id', metavar='<workload_id>', help='ID of the workload.')		
#@utils.service_type('workloads')		
#def do_workload_discover_instances(cs, args):		
#    """Show instances of a workload."""		
#    instances = cs.workloads.discover_instances(args.workload_id)		
#    if 'instances' in instances:		
#       instances = instances.pop('instances')
#
#    inst = []		
#    for item in instances:		
#        d = dict()		
#        d['Name'] = str(item['vm_name'])		
#        datastores = ast.literal_eval(item['vm_metadata']['datastores'])		
#        for ds in datastores:		
#            if ds['_type'] == 'Datastore':		
#               d['Datastore'] = ds['name']		
#        d['Resource Pool'] = ast.literal_eval(item['vm_metadata']['resourcepool'])['name']		
#        d['VM Folder'] = ast.literal_eval(item['vm_metadata']['parent'])['name']		
#        clusters = ast.literal_eval(item['vm_metadata']['cluster'])		
#        for cl in clusters:		
#            if cl['_type'] == 'Cluster':		
#               d['Cluster'] = cl['name']		
#        hosts = ast.literal_eval(item['vm_metadata']['host'])		
#        for hs in hosts:		
#            if hs['_type'] == 'Host':		
#               d['Host'] = hs['name']		
#        networks = ast.literal_eval(item['vm_metadata']['networks'])		
#        for nt in networks:		
#            if nt['_type'] == 'Network':		
#               d['Network'] = nt['name']		
#        d['VM Power State'] = str(item['vm_power_state'])		
#        inst.append(d)		
#		
#    utils.print_dict_vertically(inst,['Instances','Value']) '''		

@utils.arg('--all',
           type=strutils.bool_from_string, metavar='{True,False}',
           help='List all workloads of all the projects(valid for admin user only)',
           default=False)
@utils.arg('--nfsshare',
           metavar='<nfsshare>',
           help='List all workloads of nfsshare (valid for admin user only)',
           default=None)
@utils.service_type('workloads')
def do_workload_list(cs, args):
    """List all the workloads of current project."""
    search_opts = {'all_workloads': args.all, 'nfs_share': args.nfsshare}
    workloads = cs.workloads.list(search_opts=search_opts)
    columns = ['ID', 'Name', 'Project_ID', 'Workload_Type_ID', 'Status', 'Created_at']
    utils.print_list(workloads, columns)

@utils.service_type('workloads')
def do_workload_get_importworkloads_list(cs, args):
    """Get list of workloads to be imported."""
    workloads = cs.workloads.get_importworkloads_list()
    columns = ['ID', 'Name', 'Workload_Type_ID', 'Project_ID']
    utils.print_list(workloads, columns)

@utils.arg('--workloadids',
     metavar="<workloadid>",
     action='append',
     dest='workloadids',
     default=[],
     help=  "Specify workload ids  "
            " to import only specified workloads "
            "--workloadids <workloadid> --workloadids <workloadid>")
#@utils.arg('--upgrade', metavar='<upgrade>', type=strutils.bool_from_string, default=True, help="Specify True or False. Default is True")
@utils.service_type('workloads')
def do_workload_importworkloads(cs, args):
    """Import all workload records from backup store."""    
    workloads = cs.workloads.importworkloads(args.workloadids)
    columns = ['ID', 'Name', 'Workload_Type_ID']
    utils.print_list(workloads, columns)
    
@utils.service_type('workloads')
def do_workload_get_nodes(cs, args):
    """Get all the nodes of a workload manager"""
    nodes = cs.workloads.get_nodes()
    utils.print_list(nodes['nodes'], ['node','id','version','ipaddress','is_controller','status'])

'''@utils.arg('--hostname', metavar='<host>',
           help='Name of the compute node',
           default='all')
@utils.arg('--ip', metavar='<ip>', help='IP address of compute node', default='all')           
def do_status_contego(cs, args):
    """Get contego service status running on a compute node"""   
    services = cs.workloads.get_contego_status(args.hostname, args.ip)    
    contego_status_all = []
    for key,val in services.items():
        val['host'] = key   
        contego_status_all.append(val)
    utils.print_list(contego_status_all, ['host', 'name', 'status','id', 'running_state'])'''
     
@utils.arg('ip', metavar='<ip>', help='IP or hostname of node to remove')
@utils.service_type('workloads')
def do_workload_remove_node(cs, args):
    """Remove workload node by ipaddress / hostname"""
    cs.workloads.remove_node(args.ip)

'''
@utils.arg('ip', metavar='<ip>', help='IP of node to add')
@utils.service_type('workloads')
def do_workload_add_node(cs, args):
    """Add workload node by ipaddress"""
    cs.workloads.add_node(args.ip)'''
    
@utils.service_type('workloads')
def do_workload_get_storage_usage(cs, args):
    """Get total storage used by workload manager"""
    storage_usage = cs.workloads.get_storage_usage()
    for storage in storage_usage['storage_usage']:
        for key,val in storage.items():
            if type(val).__name__ == 'int' or type(val).__name__ == 'float':
               val =str(val)+" Bytes or Approx ( "+utils.bytes_fmt(val)+" )"
            storage[key] = str(val)
        utils.print_dict(storage, wrap=100)

'''
@utils.arg('--time_in_minutes', metavar='<time_in_minutes>', default=600, help='time in minutes')
@utils.service_type('workloads')    
def do_workload_get_recentactivities(cs, args):
    """Get recentactivities of workload manager"""
    recentactivities = cs.workloads.get_recentactivities(args.time_in_minutes)
    utils.print_list(recentactivities['recentactivites'],['activity_result','activity_time','activity_description','activity_type'])
'''

@utils.arg('--time_in_minutes', metavar='<time_in_minutes>', default=1440, help='time in minutes(default is 24 hrs.)')
@utils.arg('--time_from', metavar='<time_from>', help="From date time in format 'MM-DD-YYYY'", default=None)
@utils.arg('--time_to', metavar='<time_to>', help="To date time in format 'MM-DD-YYYY'(defult is current day)", default=None)
@utils.service_type('workloads')    
def do_workload_get_auditlog(cs, args):
    """Get auditlog of workload manager"""
    auditlog = cs.workloads.get_auditlog(args.time_in_minutes, args.time_from, args.time_to)
    #utils.print_dict(auditlog['auditlog'], wrap=100)    
    utils.print_list(auditlog['auditlog'], ['UserName', 'ObjectName','Timestamp', 'UserId','Details'])

'''
@utils.arg('--time_in_minutes', metavar='<time_in_minutes>', default=None, help='time in minutes')
@utils.arg('--status', metavar='<status>', default=None, help='status of tasks')
@utils.arg('--page', metavar='<page>', default=None, help='offset to start out of total records')
@utils.arg('--size', metavar='<size>', default=None, help='total records')
@utils.service_type('workloads')
def do_tasks_list(cs, args):
    """Get all tasks with or without filters"""
    tasks = cs.workloads.get_tasks(args.time_in_minutes, args.status, args.page, args.size)
    utils.print_list(tasks['tasks'],['display_name','display_description','status','created_at'])    
'''

@utils.arg('--setting',
     metavar="<key=key-name>",
     action='append',
     dest='settings',
     required=True,
     help=  "Required, Specify a key value pairs to include in the settings "
            "Specify option multiple times to include multiple settings. "
            "key=value")
@utils.service_type('workloads')
def do_add_new_settings(cs, args):
    """Settings."""

    settings = {}
    for settings_str in args.settings:
        err_msg = ("Invalid settings argument '%s'. settings arguments must be of the "
                   "form --setting <key=value>" % settings_str)

        for kv_str in settings_str.split(","):
            try:
                k, v = kv_str.split("=", 1)
            except ValueError as e:
                raise exceptions.CommandError(err_msg)

            if k in settings:
                settings[k] = v
            else:
                settings.setdefault(k, v)  
    
    settings = cs.workloads.settings(settings)
    utils.print_dict(settings, wrap=100)       
    

@utils.arg('workload_id', metavar='<workload_id>',
           help='ID of the workload to delete.')
@utils.service_type('workloads')
def do_workload_delete(cs, args):
    """Remove a workload."""
    workload = _find_workload(cs, args.workload_id)
    workload.delete()

@utils.arg('workload_id', metavar='<workload_id>',
           help='ID of the workload to snapshot.')
@utils.arg('--full',
    dest='full',
    action="store_true",
    default=False,
    help='Specify if a full snapshot is required.')
@utils.arg('--display-name', metavar='<display-name>',
           help='Optional snapshot name. (Default=None)',
           default=None)
@utils.arg('--display-description', metavar='<display-description>',
           help='Optional snapshot description. (Default=None)',
           default=None)
@utils.service_type('workloads')
def do_workload_snapshot(cs, args):
    """Snapshots a workload."""
    workload = _find_workload(cs, args.workload_id)
    workload.snapshot(args.full, args.display_name, args.display_description)

@utils.arg('--workloadids',
     metavar="<workloadid>",
     action='append',
     dest='workloadids',
     required=True,
     help="Required atleast one workloadid , Specify an ID of the workload whose scheduler disables. "
           "Specify option multiple times to include multiple workloads. "
           "--workloadids <workloadid> --workloadids <workloadid>")
@utils.service_type('workloads')
def do_disable_scheduler(cs, args):
    """disables scheduler"""
    invalid_ids = []

    for workload_id in args.workloadids:
        try:
           workload = _find_workload(cs, workload_id)
           workload.pause()
        except Exception as ex:
           if "No workload with a name or ID" in ex.message:
              invalid_ids.append(workload_id)
           else:
               raise ex
	  
    if len(invalid_ids):
	   msg = ("Found invalid workload id's in the input. \n"
                  "List of invalid id's: %s" %(str(invalid_ids))
                 )
           raise exceptions.CommandError(msg)
 
@utils.arg('--workloadids',
     metavar="<workloadid>",
     action='append',
     dest='workloadids',
     required=True,
     help="Required atleast one workloadid , Specify an ID of the workload whose scheduler enables. "
           "Specify option multiple times to include multiple workloads. "
           "--workloadids <workloadid> --workloadids <workloadid>")
@utils.service_type('workloads')
def do_enable_scheduler(cs, args):
    """enables scheduler"""
    invalid_ids = []

    for workload_id in args.workloadids:
        try:
           workload = _find_workload(cs, workload_id)
           workload.resume()
        except Exception as ex:
           if "No workload with a name or ID" in ex.message:
              invalid_ids.append(workload_id)
           else:
               raise ex

    if len(invalid_ids):
           msg = ("Found invalid workload id's in the input. \n"
                  "List of invalid id's: %s" %(str(invalid_ids))
                 )
           raise exceptions.CommandError(msg)

@utils.arg('workload_id', metavar='<workload_id>',
           help='ID of the workload to unlock.')
@utils.service_type('workloads')
def do_workload_unlock(cs, args):
    """unlock a workload."""
    workload = _find_workload(cs, args.workload_id)
    workload.unlock()  

@utils.arg('workload_id', metavar='<workload_id>',
           help='ID of the workload to reset.')
@utils.service_type('workloads')
def do_workload_reset(cs, args):
    """reset a workload."""
    workload = _find_workload(cs, args.workload_id)
    workload.reset()  

@utils.arg('snapshot_id', metavar='<snapshot_id>', help='ID of the workload snapshot.')
@utils.arg('--output', metavar='<output>', default=None, 
             help="Option to get additional snapshot details, "
                  "Specify --output metadata for snapshot metadata, "
                  "Specify --output networks for snapshot vms networks, "
                  "Specify --output disks for snapshot vms disks")
@utils.service_type('workloads')
def do_snapshot_show(cs, args):
    """Show details about a workload snapshot"""
    snapshot = _find_snapshot(cs, args.snapshot_id)
    info = dict()
    instances = dict()
    metadata = dict()

    info.update(snapshot._info)
    if 'links' in info:
        info.pop('links')

    if 'instances' in info:
       instances = info.pop('instances')

    if 'metadata' in info:
       metadata = info.pop('metadata')
    
    inst = []
    networks = []
    vdisks = []
    for item in instances:
        d = dict()
        d['Name'] = str(item['name'])
        if 'imported_from_vcenter' in item['metadata']:
            datastores = ast.literal_eval(item['metadata']['datastores'])
            for ds in datastores:
                if ds['_type'] == 'Datastore':
                   d['Datastore'] = ds['name']
            d['Resource Pool'] = ast.literal_eval(item['metadata']['resourcepool'])['name']
            d['VM Folder'] = ast.literal_eval(item['metadata']['parent'])['name']
            clusters = ast.literal_eval(item['metadata']['cluster'])
            for cl in clusters:
                if cl['_type'] == 'Cluster':
                   d['Cluster'] = cl['name']
            hosts = ast.literal_eval(item['metadata']['host'])
            for hs in hosts:
                if hs['_type'] == 'Host':
                   d['Host'] = hs['name']
            networks += ast.literal_eval(item['metadata']['networks'])
            vdisks += ast.literal_eval(item['metadata']['vdisks'])
            for nt in networks:
                if nt['_type'] == 'Network':
                   d['Network'] = nt['name']
            d['VM Power State'] = str(item['status'])
        else:
            d['Status'] = str(item['status'])
            #TODO: nics is a long string... need to handle correctly
            #d['NICs'] = str(item['nics'])
            if 'flavor' in item:
               d['Flavor'] = str(item['flavor'])
            if 'security_group' in item:
               d['Security Group'] = str(item['security_group'])
            d['ID'] = str(item['id'])

            for index, nic in enumerate(item['nics']):
                item['nics'][index]['vm_id'] = item['id']
            for index, disk in enumerate(item['vdisks']):
                item['vdisks'][index]['vm_id'] = item['id']

            networks += ast.literal_eval(str(item['nics']))
            vdisks += ast.literal_eval(str(item['vdisks']))

        inst.append(d)

    meta = []
    for item in metadata:
        m = dict()
        m[str(item['key'])] = str(item['value'])
        meta.append(m)

    info['size'] = str(info['size']) + ' Bytes or Approx (' + utils.bytes_fmt(info['size']) + ')'

    info['restore_size'] = str(info['restore_size']) + ' Bytes or Approx (' + utils.bytes_fmt(info['restore_size']) + ')'

    info['time_taken'] = str(info['time_taken']) + ' Seconds'

    [info.pop(k) for k in ['pinned','created_at','finished_at','updated_at', 'user_id','project_id']]
    if not info['warning_msg']:
        info.pop('warning_msg')

    if info['status'] != 'error':
        info.pop('error_msg')

    if info['status'] in set(['available', 'error', 'mounted']):
        info.pop('progress_msg')

    if not info['status'] in set(['available']):
        info.pop('restore_size')

    if info['status'] in set(['mounted']):
        for m in meta:
            if 'mounturl' in m:
               info['mounturl'] = m['mounturl']
               break
      
    utils.print_dict(info,'Snapshot property')

    utils.print_dict_vertically(inst,['Instances','Value'])
    if args.output == 'networks':
       utils.print_dict_vertically(networks,['Networks','Value'])
    elif args.output == 'disks':
         utils.print_dict_vertically(vdisks,['Vdisks','Value'])
    elif args.output == 'metadata':
         utils.print_dict_vertically(meta,['Metadata','Value'])

@utils.arg('--workload_id',
           metavar='<workload_id>',
           default=None,
           help='Filter results by workload_id')
@utils.arg('--tvault_node', metavar='<host>',
           help='List all the snapshot operations scheduled on a tvault node(Default=None)',
           default=None)
@utils.arg('--date_from', metavar='<date_from>', help="From date in format 'YYYY-MM-DDTHH:MM:SS' eg 2016-10-10T00:00:00, If don't specify time then it takes 00:00 by default", default=None)
@utils.arg('--date_to', metavar='<date_to>', help="To date in format 'YYYY-MM-DDTHH:MM:SS'(defult is current day), Specify HH:MM:SS to get snapshots within same day inclusive/exclusive results for date_from and date_to", default=None)
@utils.arg('--all',
           type=strutils.bool_from_string, metavar='{True,False}',
           help='List all snapshots of all the projects(valid for admin user only)',
           default=False)
@utils.service_type('workloads')
def do_snapshot_list(cs, args):
    """List all the workloads."""
    search_opts = {
        'host': args.tvault_node,
        }
    search_opts['workload_id'] = args.workload_id
    search_opts['all'] = args.all
    search_opts['date_from'] = args.date_from
    search_opts['date_to'] = args.date_to
    snapshots = cs.snapshots.list(search_opts=search_opts)
    columns = ['Created At', 'Name', 'ID', 'Workload ID', 'Snapshot Type','Status','Host']
    utils.print_list(snapshots, columns)

@utils.arg('snapshot_id', metavar='<snapshot_id>',
           help='ID of the workload snapshot to delete.')
@utils.service_type('workloads')
def do_snapshot_delete(cs, args):
    """Remove a workload snapshot."""
    snapshot = _find_snapshot(cs, args.snapshot_id)
    snapshot.delete()
    
@utils.arg('snapshot_id', metavar='<snapshot_id>',
           help='ID of snapshot to cancel.')
@utils.service_type('workloads')
def do_snapshot_cancel(cs, args):
    """Cancel a snapshot."""
    snapshot = _find_snapshot(cs, args.snapshot_id)
    snapshot.cancel()    
    
@utils.arg('snapshot_id', metavar='<snapshot_id>',
           help='ID of the workload snapshot to restore.')
#@utils.arg('--test',
#    dest='test',
#    action="store_true",
#    default=False,
#    help='Specify if testing of a restore is required')
@utils.arg('--display-name', metavar='<display-name>',
           help='Optional name for the restore. (Default=None)',
           default="One Click Restore")
@utils.arg('--display-description', metavar='<display-description>',
           help='Optional description for restore. (Default=None)',
           default="One Click Restore")
#@utils.arg('--options', metavar='<options>',
#           help="Restore options. (Default={'openstack': {}, 'type': 'vmware', 'oneclickrestore': True, 'vmware': {}})",
#           default="{'openstack': {}, 'type': 'vmware', 'oneclickrestore': True, 'vmware': {}}")
@utils.service_type('workloads')
def do_snapshot_oneclick_restore(cs, args):
    """Restore a workload snapshot."""
    snapshot = _find_snapshot(cs, args.snapshot_id)
    options = ast.literal_eval("{'openstack': {}, 'type': 'vmware', 'oneclickrestore': True, 'vmware': {}}")
    snapshot.restore(False, args.display_name, args.display_description, options)

@utils.arg('snapshot_id', metavar='<snapshot_id>',
           help='ID of the workload snapshot to restore.')
#@utils.arg('--test',
#    dest='test',
#    action="store_true",
#    default=False,
#    help='Specify if testing of a restore is required')
@utils.arg('--display-name', metavar='<display-name>',
           help='Optional name for the restore. (Default=None)',
           default="Selective Restore")
@utils.arg('--display-description', metavar='<display-description>',
           help='Optional description for restore. (Default=None)',
           default="Selective Restore")
@utils.arg('--filename', metavar='<filename>',
           help="File path including file name , By default it will search into input-files folder,"
                "residing into python-workloadmgrclient directory, Can replace this with absolute path,"
                "Can also specify relative path respect to python-workloadmgrclient folder"
                "(Default=input-files/restore.json) | replace values into sample files",
           default=False)
@utils.service_type('workloads')
def do_snapshot_selective_restore(cs, args):
    """Selective restore workload snapshot."""
    snapshot = _find_snapshot(cs, args.snapshot_id)
    if args.filename is False:
       args.filename = os.path.join(os.path.dirname(__file__),'../input-files/restore.json')
    if os.path.isabs(args.filename) is False:
       args.filename = os.path.join(os.path.dirname(__file__),'../'+args.filename)
    try:
        json_data=open(args.filename).read()
    except Exception as ex:
           print("Error: "+ex.strerror+"\nIn reading "+os.path.basename(args.filename))
           exit()         
    json_data = json_data.replace('\n', '').strip()
    try:
        options = ast.literal_eval(json_data)
    except Exception as ex:
           print("Error: "+ex.msg+"\nIn parsing "+os.path.basename(args.filename))
           exit()
    snapshot.restore(False, args.display_name, args.display_description, options)
    
@utils.arg('snapshot_id', metavar='<snapshot_id>',
           help='ID of the workload snapshot to mount.')
@utils.arg('mount_vm_id', metavar='<mount_vm_id>',
           help='VM ID that snapshot volumes mount to.')
@utils.arg('--options', metavar='<options>',
           help='Mount options. (Default={})',
           default='{}')
@utils.service_type('workloads')
def do_snapshot_mount(cs, args):
    """Mount a workload snapshot."""
    snapshot = _find_snapshot(cs, args.snapshot_id)
    options = ast.literal_eval(args.options)
    mounturl = snapshot.mount(args.mount_vm_id, options)
    print('Please run "workloadmgr snapshot-show --output metadata %s" to '
          'get the snapshot status' % args.snapshot_id)
        
@utils.arg('snapshot_id', metavar='<snapshot_id>',
           help='ID of the workload snapshot to dismount.')
@utils.service_type('workloads')
def do_snapshot_dismount(cs, args):
    """Dismount a workload snapshot."""
    snapshot = _find_snapshot(cs, args.snapshot_id)
    snapshot.dismount()

@utils.arg('--workloadid', metavar='<workloadid>',
           help='Workload id (Default=None)',
           default=None)
@utils.service_type('workloads')
def do_snapshot_mounted_list(cs, args):
    """List of all mounted snapshots"""
    snapshots = cs.snapshots.snapshot_mounted_list(args.workloadid)
    utils.print_list(snapshots['mounted_snapshots'],['snapshot_id','snapshot_name','workload_id','mounturl'])

@utils.arg('restore_id', metavar='<restore_id>', help='ID of the restore.')
@utils.arg('--output', metavar='<output>', help="Option to get additional restore details, "
                  "Specify --output metadata for restore metadata,"
                  "--output networks "
                  "--output subnets "
                  "--output routers "
                  "--output flavors ")
@utils.service_type('workloads')
def do_restore_show(cs, args):
    """Show details about a workload snapshot restore"""
    restore = _find_restore(cs, args.restore_id)
    info = dict()
    info.update(restore._info)
    networks = []
    subnets = []
    routers = []
    flavors = []

    if 'links' in info:
        info.pop('links')

    if 'snapshot_details' in info:
       info.pop('snapshot_details')

    if 'metadata' in info:
       metadata = info.pop('metadata')

    if 'networks' in info:
        networks = info.pop('networks')

    if 'subnets' in info:
       subnets = info.pop('subnets')

    if 'routers' in info:
       routers = info.pop('routers')

    if 'flavors' in info:
       flavors = info.pop('flavors')

    meta = []
    for item in metadata:
        m = dict()
        m[str(item['key'])] = str(item['value'])
        meta.append(m)

    utils.print_dict(info, wrap=100)
    if args.output == 'metadata':
       utils.print_dict_vertically(meta,['Metadata','Value']) 
    if args.output == 'networks':
       utils.print_dict_vertically(networks,['Networks','Value'])
    if args.output == 'subnets':
       utils.print_dict_vertically(subnets,['Subnets','Value'])
    if args.output == 'routers':
       utils.print_dict_vertically(routers,['Routers','Value'])
    if args.output == 'flavors':
       utils.print_dict_vertically(flavors,['Flavors','Value'])

@utils.arg('--snapshot_id',
           metavar='<snapshot_id>',
           default=None,
           help='Filter results by snapshot_id')
@utils.service_type('workloads')
def do_restore_list(cs, args):
    """List all the restores."""

    search_opts = {
        'snapshot_id': args.snapshot_id,
    }
    restores = cs.restores.list(search_opts=search_opts)
    columns = ['Created At', 'Name', 'ID', 'Snapshot ID', 'Size', 'Status']
    utils.print_list(restores, columns)


@utils.arg('restore_id', metavar='<restores_id>',
           help='ID of the restore to delete.')
@utils.service_type('workloads')
def do_restore_delete(cs, args):
    """Delete a restore."""
    restore = _find_restore(cs, args.restore_id)
    restore.delete()

@utils.arg('restore_id', metavar='<restore_id>',
           help='ID of restore to cancel.')
@utils.service_type('workloads')
def do_restore_cancel(cs, args):
    """Cancel a restore."""
    restore = _find_restore(cs, args.restore_id)
    restore.cancel()

"""@utils.arg('testbubble_id', metavar='<testbubble_id>', help='ID of the testbubble.')
@utils.service_type('workloads')
def do_testbubble_show(cs, args):
    testbubble = _find_testbubble(cs, args.testbubble_id)
    info = dict()
    info.update(testbubble._info)

    if 'links' in info:
        info.pop('links')

    utils.print_dict(info, wrap=100)

@utils.arg('--snapshot_id',
           metavar='<snapshot_id>',
           default=None,
           help='Filter results by snapshot_id')
@utils.service_type('workloads')
def do_testbubble_list(cs, args):

    search_opts = {
        'snapshot_id': args.snapshot_id,
    }
    testbubbles = cs.testbubbles.list(search_opts=search_opts)
    columns = ['ID', 'Snapshot ID', 'Status']
    utils.print_list(testbubbles, columns)


@utils.arg('testbubble_id', metavar='<testbubbles_id>',
           help='ID of the testbubble to delete.')
@utils.service_type('workloads')
def do_testbubble_delete(cs, args):
    testbubble = _find_testbubble(cs, args.testbubble_id)
    testbubble.delete()"""


@utils.arg('name', metavar='<name>',
           help='name of the setting')
@utils.arg('value', metavar='<vaule>',
           help='Value of the setting')
@utils.arg('--description', metavar='<description>',
           help='Optional description. (Default=None)',
           default=None)
@utils.arg('--category', metavar='<category>',
           help='Optional category. (Default=None)',
           default=None)
@utils.arg('--type', metavar='<type>',
           help='Optional type of setting. (Default=None)',
           default=None)
@utils.arg('--is-public',
           type=strutils.bool_from_string, metavar='{True,False}',
           help='Make setting accessible to the public.',
           default=False)
@utils.arg('--is-hidden',
           type=strutils.bool_from_string, metavar='{True,False}',
           help='Make setting hidden.',
           default=False)
@utils.arg('--metadata',
     metavar="<key=value>",
     action='append',
     dest='metadata',
     default=[],
     help=  "Specify a key value pairs to include in the settings metadata "
            "Specify option multiple times to include multiple keys. "
            "key=value")
@utils.service_type('workloads')
def do_setting_create(cs, args):
    """Creates a setting."""
    metadata = {}
    for metadata_str in args.metadata:
        err_msg = ("Invalid metadata argument '%s'. metadata arguments must be of the "
                   "form --metadata <key=value>" % metadata_str)

        try:
            k, v = metadata_str.split("=", 1)
        except ValueError as e:
            raise exceptions.CommandError(err_msg)

        if k in metadata:
            metadata[k] = v
        else:
            metadata.setdefault(k, v)

   
    cs.settings.create(args.name,
                       args.value,
                       args.description,
                       args.category,
                       args.type,
                       args.is_public,
                       args.is_hidden,
                       metadata)

@utils.arg('name', metavar='<name>',
           help='name of the setting')
@utils.arg('value', metavar='<vaule>',
           help='Value of the setting')
@utils.arg('--description', metavar='<description>',
           help='Optional description. (Default=None)',
           default=None)
@utils.arg('--category', metavar='<category>',
           help='Optional category. (Default=None)',
           default=None)
@utils.arg('--type', metavar='<type>',
           help='Optional type of setting. (Default=None)',
           default=None)
@utils.arg('--is-public',
           type=strutils.bool_from_string, metavar='{True,False}',
           help='Make setting accessible to the public.',
           default=False)
@utils.arg('--is-hidden',
           type=strutils.bool_from_string, metavar='{True,False}',
           help='Make setting hidden.',
           default=False)
@utils.arg('--metadata',
     metavar="<key=value>",
     action='append',
     dest='metadata',
     default=[],
     help=  "Specify a key value pairs to include in the settings metadata "
            "Specify option multiple times to include multiple keys. "
            "key=value")
@utils.service_type('workloads')
def do_setting_update(cs, args):
    """Creates a setting."""
    metadata = {}
    for metadata_str in args.metadata:
        err_msg = ("Invalid metadata argument '%s'. metadata arguments must be of the "
                   "form --metadata <key=value>" % metadata_str)

        try:
            k, v = metadata_str.split("=", 1)
        except ValueError as e:
            raise exceptions.CommandError(err_msg)

        if k in metadata:
            metadata[k] = v
        else:
            metadata.setdefault(k, v)

   
    cs.settings.update(args.name,
                       args.value,
                       args.description,
                       args.category,
                       args.type,
                       args.is_public,
                       args.is_hidden,
                       metadata)

   
@utils.arg('setting_name', metavar='<setting_name>', help='name of the setting.')
@utils.arg('--get_hidden',
           type=strutils.bool_from_string, metavar='{True,False}',
           help='show hidden settings',
           default=False)
@utils.service_type('workloads')
def do_setting_show(cs, args):
    """Show details of a setting."""
    setting = cs.settings.get(args.setting_name, args.get_hidden)
    if setting == None:
        print('Setting not found')
    else:
        utils.print_dict(setting, wrap=100)

@utils.arg('--get_hidden',
           type=strutils.bool_from_string, metavar='{True,False}',
           help='show hidden settings',
           default=False)
@utils.service_type('workloads')
def do_setting_list(cs, args):
    """List all the settings."""
    settings = cs.settings.list(args.get_hidden)
    d = {}
    for v in settings:
        if type(v) is dict:
           for k , v1 in v['settings'].items():
               d.setdefault(k, str(v1))

    columns = 'Name'
    utils.print_dict(d, columns)


@utils.arg('setting_name', metavar='<setting_name>',
           help='name of setting to delete.')
@utils.service_type('workloads')
def do_setting_delete(cs, args):
    """Remove a setting."""
    cs.settings.delete(args.setting_name)


@utils.arg('role_name', metavar='<role_name>',
           help='name of the role that user what to delete to triliovault service.')
@utils.service_type('workloads')
def do_trust_create(cs, args):
    """Creates a trust."""
    trusts = cs.trusts.create(args.role_name)
    d = {}
    columns = 'Name'
    for v in trusts:
        if type(v) is dict:
           for k , v1 in v.items():
               d.setdefault(k, str(v1))

           utils.print_dict(d, columns)


@utils.arg('trust_id', metavar='<trust_id>', help='trust ID.')
@utils.service_type('workloads')
def do_trust_show(cs, args):
    """Show details of a trust."""
    trust = cs.trusts.get(args.trust_id)
    if trust == None:
        print('Trust not found')
    else:
        utils.print_dict(trust, wrap=100)


@utils.service_type('workloads')
def do_trust_list(cs, args):
    """List all the trusts."""
    trusts = cs.trusts.list()
    columns = 'Name'
    for v in trusts:
        if type(v) is dict:
           d = {}
           for k , v1 in v.items():
               if k == 'name':
                  k = 'trust_id'
               d.setdefault(k, str(v1))

           utils.print_dict(d, columns)


@utils.arg('trust_id', metavar='<trust_id>',
           help='ID of trust to delete.')
@utils.service_type('workloads')
def do_trust_delete(cs, args):
    """Remove a trust."""
    cs.trusts.delete(args.trust_id)

@utils.service_type('workloads')
def do_enable_global_job_scheduler(cs, args):
    """Enable global job scheduler."""
    job_scheduler = cs.global_job_scheduler.enable()
    if job_scheduler:
        print('Global job scheduler is successfully enabled')
    else:
        print('Global job scheduler is not enabled')

@utils.service_type('workloads')
def do_disable_global_job_scheduler(cs, args):
    """Disable global job scheduler."""
    job_scheduler = cs.global_job_scheduler.disable()
    if job_scheduler:
        print('Global job scheduler is still running')
    else:
        print('Global job scheduler is successfully disabled')

@utils.service_type('workloads')
def do_get_global_job_scheduler(cs, args):
    """Show status of global job scheduler."""
    enabled = cs.global_job_scheduler.get()
    if enabled:
        print('Global job scheduler enabled')
    else:
        print('Global job scheduler disabled')


@utils.arg('license_text', metavar='<license_text>',
           help='License text for TrilioVault')
@utils.service_type('workloads')
def do_license_create(cs, args):
    """Creates a license. (Admin only)"""
    license = cs.workloads.license_create(args.license_text)
    utils.print_dict(license, wrap=100)


@utils.service_type('workloads')
def do_license_list(cs, args):
    """List the license. (Admin only)"""
    license = cs.workloads.license_list()
    utils.print_dict(license, wrap=100)

@utils.arg('--migrate_cloud',
     metavar='{True,False}',
     type=strutils.bool_from_string,
     default=False,
     help=  "Set to True if want to list workloads from other clouds as well. Default if False")
@utils.arg('--generate_yaml',
     metavar='{True,False}',
     type=strutils.bool_from_string,
     default=False,
     help=  "Set to True if want to generate output file in yaml format,\
             which would be further used as input for workload reassign API.")
@utils.service_type('workloads')
def do_workload_get_orphaned_workloads_list(cs, args):
    """
    List all the orphaned workloads having tenant_id or user_id which doesn't belong to current cloud.
    """
    workloads = cs.workloads.get_orphaned_workloads_list(args)
    columns = ['Name','ID', 'Project ID', 'User ID']
    utils.print_list(workloads, columns)
    if args.generate_yaml:
        print ("\nPlease find map file at " + str(os.getcwd()) + "/reassign_map.yaml\n")

@utils.arg('--old_tenant_ids',
     metavar="<old_tenant_id>",
     action='append',
     dest='old_tenant_ids',
     default=[],
     help=  "Specify old tenant ids"
            " from which workloads need to reassign to new tenant. "
            "--old_tenant_ids <old_tenant_id> --old_tenant_ids <old_tenant_id>")
@utils.arg('--new_tenant_id',
     metavar="<new_tenant_id>",
     default=None,
     help=  "Specify new tenant id "
            "to which workloads need to reassign from old tenant. "
            "--new_tenant_id <new_tenant_id>")
@utils.arg('--workload_ids',
     metavar="<workload_id>",
     action='append',
     dest='workload_ids',
     default=[],
     help=  "Specify workload_ids which need to reassign to new tenant. "
            "If not provided then all the workloads from old tenant "
            "will get reassigned to new tenant. "
            "--workload_ids <workload_id> --workload_ids <workload_id>" )
@utils.arg('--user_id',
     metavar="<user_id>",
     default=None,
     help=  "Specify user id "
            "to which workloads need to reassign from old tenant. "
            "--user_id <user_id>")
@utils.arg('--migrate_cloud',
     metavar='{True,False}',
     type=strutils.bool_from_string,
     default=False,
     help=  "Set to True if want to reassign workloads from other clouds as well. Default if False")
@utils.arg('--map_file',
     metavar="<map_file>",
     default=None,
     type=file,
     help="""Provide list of old worloads mapped to new tenants.
             Format for this file is YAML. For sample, please open sample file at 
             "/opt/stack/python-workloadmgrclient/templates/workload_reassign_map_file.yaml"
          """)
@utils.service_type('workloads')
def do_workload_reassign_workloads(cs, args):
    """
    Assign workload to a new tenant/user.
    """
    workloads = cs.workloads.reassign_workloads(args)
    columns = ['Name','ID', 'Project ID', 'User ID']
    utils.print_list(workloads, columns)

'''
@utils.arg('workload', metavar='<workload>',
           help='Name or ID of workload to transfer.')
@utils.arg('--name',
           metavar='<name>',
           default=None,
           help='Transfer name. Default=None.')
@utils.arg('--display-name',
           help=argparse.SUPPRESS)
@utils.service_type('workloads')
def do_transfer_create(cs, args):
    """Creates a workload transfer."""
    if args.display_name is not None:
        args.name = args.display_name

    workload = _find_workload(cs, args.workload)
    transfer = cs.transfers.create(workload.id,
                                   args.name)
    info = dict()
    info.update(transfer._info)

    info.pop('links', None)
    utils.print_dict(info)


@utils.arg('transfer', metavar='<transfer>',
           help='Name or ID of transfer to delete.')
@utils.service_type('workloads')
def do_transfer_delete(cs, args):
    """aborts a transfer."""
    transfer = _find_transfer(cs, args.transfer)
    cs.transfers.delete(transfer.id)


@utils.arg('transfer', metavar='<transfer>',
           help='Name or ID of transfer to delete.')
@utils.service_type('workloads')
def do_transfer_complete(cs, args):
    """completes a transfer."""
    transfer = _find_transfer(cs, args.transfer)
    cs.transfers.complete(transfer.id)


@utils.arg('transfer', metavar='<transfer>',
           help='ID of transfer to accept.')
@utils.arg('auth_key', metavar='<auth_key>',
           help='Authentication key of transfer to accept.')
@utils.service_type('workloads')
def do_transfer_accept(cs, args):
    """Accepts a workload transfer."""
    transfer = cs.transfers.accept(args.transfer, args.auth_key)
    info = dict()
    info.update(transfer._info)

    info.pop('links', None)
    utils.print_dict(info)


@utils.service_type('workloads')
def do_transfer_list(cs, args):
    """Lists all transfers."""
    transfers = cs.transfers.list()
    columns = ['ID', 'Workload ID', 'Name']
    utils.print_list(transfers, columns)


@utils.arg('transfer', metavar='<transfer>',
           help='Name or ID of transfer to accept.')
@utils.service_type('workloads')
def do_transfer_show(cs, args):
    """Shows transfer details."""
    transfer = _find_transfer(cs, args.transfer)
    info = dict()
    info.update(transfer._info)

    info.pop('links', None)
    utils.print_dict(info)
'''
